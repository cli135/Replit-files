"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    // lesson learned:\n    // when you're asked to splice nodes together,\n    // you ***don't*** / hopefully shouldn't need to create new nodes!!!\n    // you can just do funcitonal and rearrange links.\n    // Thanks to Whittaker Brand for teaching me\n    // kinda functional programming.\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        // base case (beginning and ending)\n        // learned from yangliguang at\n        // https://leetcode.com/problems/merge-two-sorted-lists/discuss/9715/Java-1-ms-4-lines-codes-using-recursion\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n        // ^ this way it covers both AND and XOR\n        // for null base cases (both beginning and end),\n        // look to avoid the\n        // if && return\n        // if || return\n        // construct. Instead try this:\n        // yangliguang's method\n        // if 1 null then return 2\n        // if 2 null then return 1\n        \n        // recursive case: both are nonempty\n        if (l1.val <= l2.val) {\n            // l1 is the root, and its .next is the rest merged\n            // Java evalutes rhs before lhs yay\n            l1.next = mergeTwoLists(l1.next, l2);   \n            return l1;\n        }\n        else {\n            // l2 is the root, and the .next is the rest merged\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}"