"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        // base case\n        if (root == nullptr) {\n            return true;\n        }\n        // recursive case\n        bool allInequalityTrue = allAreLessThan(root->left, root->val) && allAreGreaterThan(root->right, root->val);\n        bool allChildrenValidBST = isValidBST(root->left) && isValidBST(root->right); \n        return allInequalityTrue && allChildrenValidBST;\n    }\n    // true if all in root are less than num\n    // false otherwise (one counterexample is enough to make false)\n    bool allAreLessThan(TreeNode * root, int num) {\n        if (root == nullptr) {\n            return true; // base case, vacuous\n            // but important\n        }\n        if (root->val >= num) {\n            return false;\n        }\n        return allAreLessThan(root->left, num) && allAreLessThan(root->right, num);\n    }\n    \n    bool allAreGreaterThan(TreeNode * root, int num) {\n        if (root == nullptr) {\n            return true; // base case, vacuous\n            // but important\n        }\n        if (root->val <= num) {\n            return false;\n        }\n        return allAreGreaterThan(root->left, num) && allAreGreaterThan(root->right, num);\n    }\n    \n    \n};"